in GalleryInput.tsx containing:
[ 'use client';

import { useEffect, useRef, useState } from 'react';
import modelMap from '@/utils/modelMap';

type Props = {
  value: string;
  onChange: (value: string) => void;
};

export default function GalleryInput({ value, onChange }: Props) {
  const [inputValue, setInputValue] = useState('');
  const [error, setError] = useState('');
  const [isFocused, setIsFocused] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);
  const debounceTimer = useRef<NodeJS.Timeout | null>(null);

  const allTitles = Object.values(modelMap).map((data) =>
    data.title?.toLowerCase().trim()
  );
  const allSlugs = Object.keys(modelMap);

  const validateInput = (input: string) => {
    const normalized = input.toLowerCase().trim();
    const isValid = allTitles.includes(normalized) || allSlugs.includes(normalized);
    if (!isValid) {
      setError('No match found. Try a different search or select a Gallery card instead.');
      onChange(''); // Clear selected search
    } else {
      setError('');
      onChange(input);
    }
  };

  // Debounced validation after typing
  useEffect(() => {
    if (debounceTimer.current) clearTimeout(debounceTimer.current);

    if (inputValue.trim() === '') {
      setError('');
      return;
    }

    debounceTimer.current = setTimeout(() => {
      validateInput(inputValue);
    }, 500);

    return () => {
      if (debounceTimer.current) clearTimeout(debounceTimer.current);
    };
  }, [inputValue]);

  return (
    <div className="flex flex-col gap-1 w-72">
        <input
            id="gallery-search"
            ref={inputRef}
            type="text"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            onFocus={() => setIsFocused(true)}
            onBlur={() => setIsFocused(false)}
            placeholder={isFocused ? '' : 'Search exhibitions...'}
            className="px-4 py-2 rounded-lg border border-gray-300 shadow-sm text-gray-900 placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent transition"
        />
            {error && <p className="text-sm text-red-600">{error}</p>}
    </div>

  );
}
] rewrite such that 
-Create a gap between the icons and the h1 text with GalleryInput component such that the arrows appear to the left ( naturally like the arrows you'd see on a webpage i.e, the span becomes a little distant from the h1 and GalleryInput component) by styling :
[  return ( 
    <div className="flex items-center justify-center gap-[5px] mt-4 mb-6 px-4">
      {/* Arrow icons (SVG or your existing component) */}
      <span className="text-2xl">ü°êü°í</span>

      {/* Main Heading */}
      <h1 className="text-xl font-bold tracking-tight text-gray-900">
        VIRTUAL EXHIBITION:
      </h1>

      {/* Gallery Input (5px to the right of heading) */}
      <GalleryInput value={searchTerm} onChange={setSearchTerm} />
    </div>
  );
};] from that implement the logic that:
-The input field gets populated by either when a user clicks enter on a valid input query that matches a gallery title in modelMap after taking in  a user's search directly through typing OR its value is dynamically updated by clicking of a GalleryCard forming a selectedGallery. Maintain initial logic that typing in the input replaces placeholder text until new search or reload. When there is no search or selected galleryCard, the input field only contains placeholder text.

-Implement the arrow keys as a component called ArrowStates.tsx using realistic icons to switch between current, previous and next selected contexts. Give me necessary scripts to run using pnpm to get the icons.
-The arrow keys are implemented in context/GalleryContext.tsx by adding event listeners to the them and switching between stored selectedGallery contexts. Left arrow is used for previous and right arrow for next selectedGallery contexts. Create the storage for the current ,next and previous and an extra state here in ArrowStates.tsx. 
Under ArrowStates.tsx the selectedGallery from context is the current. Of the 4 states stored at least one must be the current state and the rest including the previous, next and extra may be any. When a new selectedGallery is created, the initial becomes previous and any previous one or two states that were selected can be accessed by clicking the left arrow which changes selectedGallery to a maximum of two previously selected if there are or one or  none.The right arrow works only if the left arrow has been clicked at least once and the selectedGallery index has gone down by 1 or 2 or the selectedGallery context is at the least index of previous.


in GalleryCard.tsx debug the buttons to donwload in Download.tsx and implement share in ShareGallery.tsx and in the code :
['use client';

import Image from 'next/image';
import Link from 'next/link';
import { GalleryData } from '@/utils/modelMap';

type Props = {
  id: string;
  data: GalleryData;
};

export default function GalleryCard({ id, data }: Props) {
  const query = new URLSearchParams({
    model: data.modelPath,
    slug: id,
    title: data.title,
  }).toString();

  return (
    <div className="relative h-full overflow-hidden rounded-[calc(var(--radius-lg)+1px)] shadow-md ring-1 ring-black/5 bg-white">
      <div className="px-8 pt-8 pb-4 sm:px-10 sm:pt-10">
        <h2 className="text-lg font-medium tracking-tight text-gray-950">{data.title}</h2>
        <p className="mt-2 text-sm text-gray-500">Category: {id}</p>
        <p className="mt-2 text-sm/6 text-gray-600">
          {data.description || 'Gallery Description: Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor.'}
        </p>
      </div>

      <div className="relative min-h-[18rem] w-full">
        <div className="absolute top-6 left-6 right-6 bottom-0 overflow-hidden rounded-t-2xl bg-gray-900 shadow-2xl">
          <Image
            src={data.image}
            alt={data.title}
            width={500}
            height={300}
            className="object-cover w-full h-full rounded-t-2xl"
          />
        </div>
      </div>

      <div className="px-8 py-4 flex justify-between items-center sm:px-10">
        <button
          href={data.pdf}
          download
          className="bg-white text-purple-900 px-4 py-2 rounded-full text-sm"
        >
          Download
        </button>
        <button
          href={`/modelPreview?${query}`}
          className="bg-white text-purple-900 px-4 py-2 rounded-full text-sm"
        >
          Share
        </button>
      </div>
    </div>
  );
}
] and implement
-Selecting a galleryCard  updates the value of the GalleryInput to match the  Title of the selected card. The  galleryCard associated with the selectedGallery gets a glowy animated outline. .
in GalleryContext.tsx containing:
["use client";

import React, { createContext, useContext, useState } from "react";

type GalleryContextType = {
  selectedGallery: string | null;
  setSelectedGallery: (gallery: string) => void;
};

const GalleryContext = createContext<GalleryContextType | undefined>(undefined);

export const useGalleryContext = (): GalleryContextType => {
  const context = useContext(GalleryContext);
  if (!context) {
    throw new Error("useGalleryContext must be used within a GalleryProvider");
  }
  return context;
};

export const GalleryProvider = ({ children }: { children: React.ReactNode }) => {
  const [selectedGallery, setSelectedGallery] = useState<string | null>(null);

  return (
    <GalleryContext.Provider value={{ selectedGallery, setSelectedGallery }}>
      {children}
    </GalleryContext.Provider>
  );
};
] implement 
-A context is created under context/GalleryContext.tsx and takes the title, description, image, model path and pdf mapped out as data to be tied and used as selectedGallery. The context is done through event or action listener or functions tied to GalleryCard and GalleryInput. 
-The management and storage of context and implementation of shift of selectedGallery enables us use modelPath in the SideContent.tsx and {GalleryTitle} used in TourButton component. 

in SideContent.tsx containing:
['use client';

import { useSearchParams } from 'next/navigation';

export default function SideContent() {
  const searchParams = useSearchParams();
  const modelUrl = searchParams.get('model') || '/models/default.glb';
  const slug = searchParams.get('slug') || '';

  return (
    <aside className="w-[30%] h-full relative h-screen">
      <iframe
        src={`/modelPreview?model=${modelUrl}&slug=${slug}`}
        className="w-full h-full border-none"
        title="3D Preview"
      />
    </aside>
  );
}
] implement
-In the SideContent, the model associated with that title is loaded for preview with no user control and this is implemented as SideDisplay.tsx. 
-SideDisplay.tsx has the model from ModelPreview.tsx which just loads selectedGallery model from GalleryContext and animates it infinitely.
-modelPreview/page.tsx only implements the model of selected gallery in a webpage/frame to be called in SideDisplay for animated preview. modelPreview/page.tsx contains and should be updated to meet new instructions from: 
[ 'use client';

import { useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { Canvas, useFrame } from '@react-three/fiber';
import { OrbitControls, useGLTF } from '@react-three/drei';
import { useRef } from 'react';
import * as THREE from 'three';

function SpinningModel({ url }: { url: string }) {
  const ref = useRef<THREE.Group>(null);
  const { scene } = useGLTF(url);

  useFrame(() => {
    if (ref.current) {
      ref.current.rotation.y += 0.005;
    }
  });

  return <primitive object={scene} ref={ref} />;
}

export default function ModelPreview() {
  const searchParams = useSearchParams();
  const modelUrl = searchParams.get('model') || '/models/default.glb';
  const slug = searchParams.get('slug') || '';
  const title = searchParams.get('title') || 'Gallery';

  return (
    <div className="h-screen max-w-full relative">
      <Canvas camera={{ position: [0, 1, 3], fov: 50 }}>
        <ambientLight intensity={1} />
        <directionalLight position={[3, 3, 3]} intensity={1.5} />
        <SpinningModel url={modelUrl} />
        <OrbitControls enableZoom={false} autoRotate={false} />
      </Canvas>

      {/* Overlay CTA */}
      <div className="absolute bottom-10 left-1/2 transform -translate-x-1/2 z-10">
        <Link href={`/gallery/${slug}`}>
          <button className="px-6 py-3 bg-purple-800 text-white font-semibold rounded-md hover:bg-purple-700 shadow-lg">
            Tour {title}
          </button>
        </Link>
      </div>
    </div>
  );
}]
-On top of SideDisplay in SideContent is a TourComponent.tsx which has a TourButton.tsx containing [ {/* Overlay CTA */}
      <div className="absolute bottom-10 left-1/2 transform -translate-x-1/2 z-10">
        <Link href={`/gallery/${slug}`}>
          <button className="px-6 py-3 bg-purple-800 text-white font-semibold rounded-md hover:bg-purple-700 shadow-lg">
            Tour {title}
          </button>
        </Link>
      </div>] in the TourButton.tsx
-Replace the {title} with selectedGallery Title from context and the button lay on top at the horizontal and vertical center of the SideContent which previews the model.
-Implement clicking the Tour button to lead the user to GalleryView.tsx which loads the model mapped from GalleryContext.tsx in a webpage with controls from UserControl.tsx well positioned. 
Ask for an image for the UI once we get to this point then continue with the instructions below.
-Controls are circular motion controls like for those used to move characters in games with one for front ,back ,left ,right and the other for 360 view manipulations. 
Keyboard and mouse movements are allowed for manipulation too. This is done in the UserControl.tsx.

Write an implementation that ensures -
-Any unexpected user actions are handled safely.
- All relevant scripts are listed using pnpm as package manager and file structures given most with files under components unless framework syntax suggests otherwise. 
-A user-centered design is maintained with no data initially passed omited. Reimplement my initial logic in files.
-Make the best UI and have a good flow of items in my UI.

Give me the file structure, updated codes and explanations with improvement suggestions at the end. Full implement my instructions and follow them.
